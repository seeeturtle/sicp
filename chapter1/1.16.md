
# Exercise 1.16

## Problem

다음과 같은 조건을 만족하는 거듭제곱을 계산하는 procedure를 만들어라:
1. successive squaring[[1]](#1) 사용해라.
2. iterative한 proccess로 해라.
3. logarithmic한 단계의 수, 즉 로그 함수에 비례하는 단계의 수를 사용해라.
4. 상태 변수 a, 밑수 b, 지수 n을 사용해라.
5. 다음 상태로 변환할때, `a*b^n`이 일정하도록 설계하라.
6. 처음 a는 1로 주어지고, 정답은 마지막으로 주어진 a가 되도록 해라.

자 그럼 문제 해설을 시작하겠습니다.

## Solution
**note**:
```
참고로 이 문제를 푸는 데 최소 한 달이 걸렸고 A4 노트 6쪽 가량을 소비했습니다...
```
제가 문제를 푼 과정(가장 마지막 시도)를 설명해드리겠습니다.

저는 이 함수가 지금 `2^8`를 구하려한다고 가정하고 풀었습니다.

우선 `(b^(n/2))^2 = (b^2)^(n/2)`를 이용하라는 힌트를 통해서 저는 a가 다음과 같은 방식으로 커져야한다고 생각했습니다:
```
1 -> 2^1 -> 2^2 -> 2^4 -> 2^8
```
마치 `fast-expt`에서 b와 n이 줄어가는 과정과도 비슷하게 보입니다.

그 다음, a는 다음 a로 넘어갈때 마다 다음과 같이 곱해집니다:
```
1
1 * 2
1 * 2 * 2
1 * 2 * 2 * 2^2
1 * 2 * 2 * 2^2 * 2^4
```
가장 처음에 b의 값은 2입니다.

그래서 저는 그냥 a가 다음 a로 넘어갈때 `a -> a*b`라는 규칙으로 된다고 가정했습니다.

자 그럼 지금 a와 b의 변화는 다음과 같습니다:
```
a  |  1  | 2^1 | 2^2 | 2^4 | 2^8
b  |  2  |  2  | 2^2 | 2^4 |  ?
```
위에서 볼 수 있듯이 책에서는 힌트로 `a*b^n`를 항상 같게하라고 했습니다.
그러면 이 힌트에 따라 n의 변화도 추가하면 다음과 같이 됩니다:
```
a  |  1  | 2^1 | 2^2 | 2^4 | 2^8
b  |  2  |  2  | 2^2 | 2^4 |  ?
n  |  8  |  7  |  3  |  1  |  0
```
**note**:
```
b^0은 항상 1입니다. 그래서 저 마지막 n은 0이 됩니다.
```

저는 여기서 n이 짝수일 경우, 홀수일 경우가 다를 거라고 예상하고, b와 n의 변화를 관찰했습니다.

b같은 경우에는 짝수일 경우, 즉, n일 8일 경우, b는 달라지지 않았습니다.(`2 -> 2`)

또한, 홀수일 경우 일때에는 `2 -> 2^2`, `2^2 -> 2^4`에서 알 수 있듯이 b는 `b -> b^2`라는 규칙으로 변화함을 알 수 있습니다.

자, 그럼 n은 어떻게 변할까요?

n이 짝수일 경우, 여기서는 n이 8일때를 보면 `8 -> 7`로 변화하며, `n -> n-1`이라는 규칙이라고 생각할 수 있습니다.

그럼 홀수일 경우도 살펴보겠습니다. n이 7, 3, 1일 때를 보면 공통된 규칙을 발견할 수 있습니다.
바로 `n -> (n-1)/2`입니다.

실제로 계산해보면, `(7-1)/2 = 3, (3-1)/2 = 1, (1-1)/2 = 0` 실제로 맞음을 알 수가 있습니다.

여기서 저는 좀 더 검증하기 위해서 저 규칙들이 실제로 `a*b^n`을 같게 유지하는 지 확인했습니다.

검증은 다음과 같습니다.
```
a*b^n에 a = a*b, b = b, n = n -1을 대입을 하면
(a * b) * (b ^ (n - 1))
= a * b * b^(n - 1)
= a * b^(n - 1 + 1)
= a * b^n
여전히 a*b^n과 같음을 알 수 있습니다.

a = a*b, b = b^2, n = (n - 1)/2를 대입을 하면
(a * b) * (b^2)^{(n - 1) / 2}
= a * b * b^{2 * (n - 1) / 2}
= a * b * b^(n - 1)
= a * b^(n - 1 + 1)
= a * b^n
역시 a*b^n과 같음을 알 수 있습니다.
```
*자 그러면 뭔가 감이 오지 않나요?*

지금까지 찾아온 규칙을 정리하겠습니다.
1. a -> a*b
2. n이 홀수일때
  - b -> b^2
  - n -> (n-1)/2
3. n이 짝수일때
  - b -> b
  - n -> n-1

네 그렀습니다. 저희는 방금 procedure를 찾아냈습니다 :-)

아 한가지가 부족하군요. 함수의 종료 조건이 아직 없습니다.
하지만 표에서 볼 수 있듯이 n이 0일때 a가 `2^8`가 됨을 알 수 있습니다.
그렇다면 종료조건은 n=0이고 그 때 a를 반환한다는 것을 알 수 있습니다.

그러면 이걸 바탕으로 코드를 짜보겠습니다.

**note**:
```
even?이라는 짝수일때 참을 반환하고, 
아니면 거짓을 반환하는 procedure가 있다고 합시다.
```
```scheme
(define (better-fast-expt a b n)
  (cond ((= n 0) a)
        ((even? n) (better-fast-expt (* a b) b (- n 1)))
        (else (better-fast-expt (* a b) (square b) (/ (- n 1) 2))))))
```

드디어 끝났습니다.

************************************************
<a name="1"></a>[1]: 제곱을 통해서 거듭제곱을 하는 방법 https://en.wikipedia.org/wiki/Exponentiation_by_squaring 참고
